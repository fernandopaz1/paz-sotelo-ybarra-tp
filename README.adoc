= Base de Datos : Trabajo Práctico

Flavio Ybarra <flavio_712@hotmail.com>; Ignacio Sotelo <nachosotelo9@gmail.com>; Fernando Paz <ferpaz9292@gmail.com>
v1, {docdate}. Docentes Hernan Rondelli y Hernan Czemerinski (COM-01)

:title-page:
:numbered:
:source-highlighter: coderay
:tabsize: 4


== Introducción

En este trabajo practico modelaremos transacciones de tarjetas de credito para ello, debemos crear una base de datos e instanciar todos los datos de clientes, tarjetas y comercios.

Por otro lado, para controlar que las compras sean validas, creamos Stored Procedures y Triggers. Finalizando con la creacion de una base de datos NoSQL basada en JSON.

== Descripción

En el curso de la resolucion del trabajo practico nos encontramos con varias dificultades que supimos resolver:

* Sintaxis del lenguaje : Acostumbrados a otro tipo de lenguaje mas flexible en donde la sintaxis no ocupaba un rol muy importante, con Go supimos padecer esta mala praxis.

* Errores en SQL : no sabiamos que errores tiraba psql pq decia que el error estaba "cerca" o a veces no era ni lo q marcaba. Solucion : comando cat var/log/postgres/postgresql-12-main.log que nos daba un historial de errores en donde los detallaba mas

* Interpretacion de la consigna : muchos veces hicimos codigo de mas o pensamos en cosas, quizas mas dificiles en resolver por lo que tardabamos mucho tiempo en hacerlas, y al final eran cosas mas faciles

* Triggers : se nos resulto complejo comprender el uso adecuado del Before y After en cada situacion, ademas de que en un principio no comprendiamos del todo como funcionaba  pero revisando las clases y la documentacion pudimos entenderlo un poco mejor


Como desicion de diseño importante en cuanto al codigo, viendo que este se hacia muy extenso, fue que se decidio separalo en varios archivos .sql y  en el archivo .go solo los ejecutabamos.


DESCRIPCION GENERAL :


== Implementación

Al ejecutar el programa, se carga un menu con diferentes opciones para que el usuario ejecute.

=== Codigo fuente en Go

[source, c]
----
package main

func main() {
	menu()
}

func menu() {
	fmt.Print("\033[H\033[2J") //Limpia la terminal

	fmt.Println(`Introduzca la opcion elegida :
				1. Para crear la base de datos
				2. Para cargar datos
				3. Para agregar las Pk y Fk
				4. Para cargar los stored procedures y triggers
				5. Testear base usando consumo
				6. Borrar Pks  y Fks
				7. Cargar base Bolt.db
				q. Salir`)
	reader := bufio.NewReader(os.Stdin)
	char, _, err := reader.ReadRune()

	if err != nil {
		fmt.Println(err)
	}

	switch char {
	case '1':
		fmt.Println("Creando")
		crearBase()
		time.Sleep(2 * time.Second)
		break
	case '2':
		fmt.Println("cargando la base")
		cargarDatos()
		time.Sleep(2 * time.Second)
		break
	case '3':
		fmt.Println("cargando PKs y FKs")
		cargarPkYFK()
		time.Sleep(2 * time.Second)
		break
	case '4':
		fmt.Println("cargando stored procedures")
		cargarProceduresYTriggers()
		time.Sleep(2 * time.Second)
		break
	case '5':
		fmt.Println("testando base con consumo")
		testearBaseConConsumo()
		time.Sleep(2 * time.Second)
		break
	case '6':
		fmt.Println("borrando PKs y FKs")
		borrarKeys()
		time.Sleep(2 * time.Second)
		break
	case '7':
		fmt.Println("creando BoltDB")
		crearBoltDB()
		time.Sleep(2 * time.Second)
		break

	case 'q':
		fmt.Println("Chau")
		return;
		break
	default:
		fmt.Println("La opcion elegida no es valida")
		time.Sleep(2 * time.Second)
	}
	menu()
}
.
.
.
----
Al ejecutar el programa, se carga un menú con diferentes opciones.

[source, c]
----
type Cliente struct {
	NroCliente                  int
	Nombre, Apellido, Domicilio string
	Telefono                    [12]rune
}

type Comercio struct {
	NroComercio                  int
	Nombre, Domicilio, CodPostal string
	Telefono                     [12]rune
}

type Tarjeta struct {
	NroCliente               int
	NroTarjeta               [16]rune
	ValidaDesde, ValidaHasta [6]rune
	CodigoSeguridad          [4]rune
	Estado                   [10]rune
	LimiteCompra             float64
}

type Compra struct {
	NroOperacion, NroComercio int
	NroTarjeta                [16]rune
	Fecha                     time.Time
	Monto                     float64
	Pagado                    bool
}

func crearBase() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=postgres sslmode=disable")
	if err != nil {
		log.Fatal(err)
		fmt.Println("Error al abrir la base de datos")
	}
	defer db.Close()

	_, err = db.Exec(`drop database if exists transacciones;`)
	if err != nil {
		log.Fatal(err)
		fmt.Println("Error al eliminar la base si ya existia")
	}

	_, err = db.Exec(`create database transacciones;`)
	if err != nil {
		log.Fatal(err)
		fmt.Println("Error al crear la base transacciones")
	}
}

func cargarDatos() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=transacciones sslmode=disable")
	if err != nil {
		fmt.Println("Error al abrir la base de datos ya creada")
		log.Fatal(err)
	}
	defer db.Close()

	cargarComandosAPostgres(db, "codigo/crearTablas.sql")

	cargarComandosAPostgres(db, "codigo/datosClientes.sql")

	cargarComandosAPostgres(db, "codigo/datosComercios.sql")

	cargarComandosAPostgres(db, "codigo/datosTarjetas.sql")

	cargarCierre(db, 2020)

	cargarComandosAPostgres(db, "codigo/datosConsumos.sql")
}
.
.
.
----
Para cargar la base de datos y sus tablas guardamos los comandos necesarios para esto en archivos .sql y que son ejecutados mediante una funcion de go llamada "crearBase()" y "cargaDatos()".

[source, c]
----
func cargarCierre(db *sql.DB, anio int) {
	d := 1
	var fechainicio string
	var fechacierre string
	var fechavto string
	for m := 1; m < 13; m++ {
		for t := 0; t < 10; t++ {
			fechainicio = fmt.Sprintf("%v-%v-%v", anio, m, d+t)
			if m < 12 {
				fechacierre = fmt.Sprintf("%v-%v-%v", anio, m+1, d+t+1)
				fechavto = fmt.Sprintf("%v-%v-%v", anio, m+1, d+t+5)
			} else {
				fechacierre = fmt.Sprintf("%v-%v-%v", anio, m-11, d+t+1)
				fechavto = fmt.Sprintf("%v-%v-%v", anio, m-11, d+t+5)
			}
			comandoSQL := fmt.Sprintf("insert into cierre values ('%v','%v','%v','%v','%v','%v');", anio, m, t, fechainicio, fechacierre, fechavto)

			_, err := db.Exec(comandoSQL)
			if err != nil {
				log.Fatal(err)
			}
		}
	}
}
.
.
.
----

Hablar sobre cargar cierre
[source, c]
----
func cargarPkYFK() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=transacciones sslmode=disable")
	if err != nil {
		fmt.Println("Error al abrir la base de datos ya creada")
		log.Fatal(err)
	}
	defer db.Close()

	cargarComandosAPostgres(db, "codigo/pks.sql")
	cargarComandosAPostgres(db, "codigo/fks.sql")

}
.
.
.
----

Como requisito para el funcionamiento del código se deben cargar las Primary Keys y Foreign Keys a travéz de la funcion cargarPkYFk()
[source, c]
----
func cargarComandosAPostgres(db *sql.DB, path string) {
	file, err := ioutil.ReadFile(path)

	if err != nil {
		log.Fatal(err)
	}

	request := string(file)

	_, err = db.Exec(request)
	if err != nil {
		log.Fatal(err)
	}
}

func cargarProceduresYTriggers() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=transacciones sslmode=disable")
	if err != nil {
		fmt.Println("Error al abrir la base de datos ya creada")
		log.Fatal(err)
	}
	defer db.Close()

	cargarComandosAPostgres(db, "codigo/funcionesAuxiliares.sql")

	cargarComandosAPostgres(db, "codigo/autorizacionDeCompra.sql")

	cargarComandosAPostgres(db, "codigo/generacionDeResumen.sql")

	cargarComandosAPostgres(db, "codigo/triggerRechazo.sql")

	cargarComandosAPostgres(db, "codigo/triggerCompra.sql")
}
.
.
.
----

En el metodo "cargarComandosAPostgres()" se ejecutan los comandos guardados en el archivos .sql pasados por parametro.

En "cargarProceduresYTriggers()" carga los Stored Procedures utilizando la funcion anterior. 

Estos procedures se fijan si la compra es valida o no, y genera el resumen dependiendo de la validez de dicha compra y carga el Trigger compra. En caso contrario, el metodo carga el Trigger para el rechazo.

Tambien cargamos stored procedures que son funcioines auxiliares, necesarias para hacer conversionersiones de tipo de dato y operaciones entre tablas.

[source, c]
----
func testearBaseConConsumo() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=transacciones sslmode=disable")
	if err != nil {
		fmt.Println("Error al abrir la base de datos ya creada")
		log.Fatal(err)
	}
	defer db.Close()

	_, err = db.Exec(`select cargar_consumos_en_compra()`)
	if err != nil {
		fmt.Println("Error al cargar el consumo")
		log.Fatal(err)
	}

	_, err = db.Exec(`select generar_resumenes_del_anio()`)
	if err != nil {
		fmt.Println("Error al cargar el consumo")
		log.Fatal(err)
	}
}
.
.
.
----
Para verificar el correcto funcionamiento de la base, se llama a la funcion "testearBaseConConsumo()". LLama al stored procedure cargar_consumo_en_compra() que carga los consumos en la tabla compra, y a generar_resumenes_del_anio() que genera los resumes de todas las tarjetas para todos los meses del año 2020.
Estas operaciones van rellenando las tablas "Alerta", "Rechazo", "Compra", entre otras que hasta el momento estaban vacias.

[source, c]
----
func borrarKeys() {
	db, err := sql.Open("postgres", "user=postgres host=localhost dbname=transacciones sslmode=disable")
	if err != nil {
		fmt.Println("Error al abrir la base de datos ya creada")
		log.Fatal(err)
	}
	defer db.Close()

	cargarComandosAPostgres(db, "codigo/removeKeys.sql")
}
.
.
.
----
se creo la funcion "borrarKeys()" la cual, como su nombre lo indica, borra todas las Primary Keys y Foreign Keys de la base de datos.

[source, c]
----
func crearBoltDB() {

	db, err := bolt.Open("bolt.db", 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	fernando := Cliente{1, "Fernando", "Paz", "Callao 345", [12]rune{'1', '1', '3', '4', '5', '6', '8', '7', '6', '5', '6', '5'}}
	data, err := json.Marshal(fernando)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "cliente", []byte(strconv.Itoa(fernando.NroCliente)), data)
	resultado1, err := ReadUnique(db, "cliente", []byte(strconv.Itoa(fernando.NroCliente)))
	fmt.Printf("%s\n", resultado1)

	manolo := Cliente{2, "Manolo", "Lettiere", "Matheu 3942", [12]rune{'1', '1', '4', '7', '5', '4', '4', '3', '6', '0'}}
	data, err = json.Marshal(manolo)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "cliente", []byte(strconv.Itoa(manolo.NroCliente)), data)
	resultado2, err := ReadUnique(db, "cliente", []byte(strconv.Itoa(manolo.NroCliente)))
	fmt.Printf("%s\n", resultado2)

	carlota := Cliente{3, "Carlota", "Correa", "San Martin 975", [12]rune{'1', '1', '9', '4', '4', '2', '7', '7', '3', '5'}}
	data, err = json.Marshal(carlota)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "cliente", []byte(strconv.Itoa(carlota.NroCliente)), data)
	resultado3, err := ReadUnique(db, "cliente", []byte(strconv.Itoa(carlota.NroCliente)))
	fmt.Printf("%s\n", resultado3)


	adidas := Comercio{1, "Adidas", "Pte peron 3221", "1643", [12]rune{'1', '1', '4', '9', '2', '1', '1', '9', '7', '1'}}
	data, err = json.Marshal(adidas)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "comercio", []byte(strconv.Itoa(adidas.NroComercio)), data)
	resultado4, err := ReadUnique(db, "comercio", []byte(strconv.Itoa(adidas.NroComercio)))
	fmt.Printf("%s\n", resultado4)

	nike := Comercio{2, "Nike", "Miraflores 2121", "1643", [12]rune{'1', '1', '4', '4', '5', '1', '8', '7', '6', '5'}}
	data, err = json.Marshal(nike)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "comercio", []byte(strconv.Itoa(nike.NroComercio)), data)
	resultado5, err := ReadUnique(db, "comercio", []byte(strconv.Itoa(nike.NroComercio)))
	fmt.Printf("%s\n", resultado5)

	mcDonals := Comercio{3, "Mc Donals", "French 231", "1643", [12]rune{'1', '1', '4', '4', '1', '1', '0', '9', '6', '5'}}
	data, err = json.Marshal(mcDonals)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "comercio", []byte(strconv.Itoa(mcDonals.NroComercio)), data)
	resultado6, err := ReadUnique(db, "comercio", []byte(strconv.Itoa(mcDonals.NroComercio)))
	fmt.Printf("%s\n", resultado6)


	compra1 := Compra{1, 1, [16]rune{'5', '1', '5', '4', '5', '6', '8', '7', '6', '5', '5', '6', '8', '7', '6', '5'}, stringATime("2020-11-27"), 150.50, false}
	data, err = json.Marshal(compra1)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "compra", []byte(strconv.Itoa(compra1.NroOperacion)), data)
	resultado7, err := ReadUnique(db, "compra", []byte(strconv.Itoa(compra1.NroOperacion)))
	fmt.Printf("%s\n", resultado7)

	compra2 := Compra{2, 3, [16]rune{'4', '0', '3', '4', '1', '6', '1', '7', '6', '5', '2', '2', '8', '0', '6', '5'}, stringATime("2020-11-27"), 150.50, false}
	data, err = json.Marshal(compra2)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "compra", []byte(strconv.Itoa(compra2.NroOperacion)), data)
	resultado8, err := ReadUnique(db, "compra", []byte(strconv.Itoa(compra2.NroOperacion)))
	fmt.Printf("%s\n", resultado8)

	compra3 := Compra{3, 3, [16]rune{'5', '5', '3', '4', '5', '6', '4', '7', '3', '3', '5', '6', '8', '5', '5', '1'}, stringATime("2020-11-27"), 150000.50, false}
	data, err = json.Marshal(compra3)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "compra", []byte(strconv.Itoa(compra3.NroOperacion)), data)
	resultado9, err := ReadUnique(db, "compra", []byte(strconv.Itoa(compra3.NroOperacion)))
	fmt.Printf("%s\n", resultado9)


	tarjeta1 := Tarjeta{2, [16]rune{'5', '4', '2', '2', '5', '6', '8', '1', '6', '2', '5', '3', '8', '7', '6', '5'}, [6]rune{'2', '0', '1', '2', '0', '2'}, [6]rune{'2', '0', '2', '8', '0', '2'}, [4]rune{'2', '4', '9', '2'}, [10]rune{'v', 'i', 'g', 'e', 'n', 't', 'e'}, 70000.00}
	data, err = json.Marshal(tarjeta1)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "tarjeta", []byte(strconv.Itoa(tarjeta1.NroCliente)), data)
	resultado10, err := ReadUnique(db, "tarjeta", []byte(strconv.Itoa(tarjeta1.NroCliente)))
	fmt.Printf("%s\n", resultado10)

	tarjeta2 := Tarjeta{3, [16]rune{'5', '5', '3', '4', '5', '6', '4', '7', '3', '3', '5', '6', '8', '5', '5', '1'}, [6]rune{'2', '0', '1', '3', '0', '1'}, [6]rune{'2', '0', '2', '9', '0', '2'}, [4]rune{'4', '4', '8', '2'}, [10]rune{'v', 'i', 'g', 'e', 'n', 't', 'e'}, 70000.00}
	data, err = json.Marshal(tarjeta2)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "tarjeta", []byte(strconv.Itoa(tarjeta2.NroCliente)), data)
	resultado11, err := ReadUnique(db, "tarjeta", []byte(strconv.Itoa(tarjeta2.NroCliente)))
	fmt.Printf("%s\n", resultado11)

	tarjeta3 := Tarjeta{5, [16]rune{'5', '3', '3', '2', '5', '9', '8', '9', '6', '3', '3', '6', '1', '7', '6', '2'}, [6]rune{'2', '0', '1', '3', '0', '4'}, [6]rune{'2', '0', '2', '1', '0', '1'}, [4]rune{'2', '1', '6', '3'}, [10]rune{'v', 'i', 'g', 'e', 'n', 't', 'e'}, 60000.00}
	data, err = json.Marshal(tarjeta3)
	if err != nil {
		log.Fatal(err)
	}
	CreateUpdate(db, "tarjeta", []byte(strconv.Itoa(tarjeta3.NroCliente)), data)
	resultado12, err := ReadUnique(db, "tarjeta", []byte(strconv.Itoa(tarjeta3.NroCliente)))
	fmt.Printf("%s\n", resultado12)

}
.
.
.
----
En esta funcion se crea una base de datos NoSQL en Bolt.db basada en JSON. Creamos tres structs por cada tipo de dato a guardar y lo marshalleamos a JSON

[source, c]
----
func CreateUpdate(db *bolt.DB, bucketName string, key []byte, val []byte) error {
	// abre transacción de escritura
	tx, err := db.Begin(true)
	if err != nil {
		return err
	}
	defer tx.Rollback()
	b, _ := tx.CreateBucketIfNotExists([]byte(bucketName))
	err = b.Put(key, val)
	if err != nil {
		return err
	}
	// cierra transacción
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

func ReadUnique(db *bolt.DB, bucketName string, key []byte) ([]byte, error) {
	var buf []byte
	// abre una transacción de lectura
	err := db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(bucketName))
		buf = b.Get(key)
		return nil
	})
	return buf, err
}

func stringATime(str string) (t time.Time) {
	layout := "2006-01-02"
	t, err := time.Parse(layout, str)
	if err != nil {
		log.Fatal(err)
	}
	return t
}
.
.
.
----


=== Codigo fuente en PSQL
[source, c]
----
create or replace function 
    autorizacion_de_compra(nro_tarj char[], nro_comercio int, fecha date, monto float, pagado boolean)  
    returns boolean as $$
    declare
        aceptado boolean = true;
        f_validez  char[];
        f_vencimiento date;
    begin
		
		select val_hasta into f_validez from tarjeta t where t.nro_tarjeta = nro_tarj;
        select into f_vencimiento array_de_char_a_date(f_validez);
        
		if exists (select * from tarjeta t where t.nro_tarjeta = nro_tarj and t.estado = '{"s","u","s","p","e","n","d","i","d","a"}') then
            insert into rechazo values (
                default, nro_tarj, nro_comercio, fecha, monto, 'la tarjeta se encuentra suspendida');
                aceptado = false;
            return aceptado;
        end if;
        
        if not exists(
            select * from tarjeta t where t.nro_tarjeta = nro_tarj and t.estado = '{"v","i","g","e","n","t","e"}') then
            insert into rechazo values (
                default, nro_tarj, nro_comercio, fecha, monto, 'tarjeta no válida ó no vigente');
            aceptado = false;
            return aceptado;
        end if;
				
        
        if not exists(
            select * from tarjeta t,consumo c
                where t.nro_tarjeta = nro_tarj and c.codigo_seguridad = t.codigo_seguridad and nro_tarj = c.nro_tarjeta) and
                    exists (select * from consumo c2 where c2.nro_tarjeta = nro_tarj) then
						insert into rechazo values (
						default, nro_tarj, nro_comercio, fecha, monto, 'código de seguridad inválido');
                        aceptado = false;
            return aceptado;
        end if;
        
        if f_vencimiento < fecha then
            insert into rechazo values (
                default, nro_tarj, nro_comercio, fecha, monto, 'plazo de vigencia expirado');
            aceptado = false;
            return aceptado;
        end if;
        
        if exists (select * from tarjeta t where t.nro_tarjeta = nro_tarj and t.limite_compra < monto ) then
            insert into rechazo values (
                default, nro_tarj, nro_comercio, fecha, monto, 'supera límite de tarjeta');
            aceptado = false;
            return aceptado;
        end if;      

        if aceptado then
            insert into compra values (default ,nro_tarj, nro_comercio , fecha, monto , pagado);
        end if;
    return aceptado;
    end; 
$$ language plpgsql;
.
.
.
----
En esta funcion comprobamos si las tarjetas estan suspendidas, que las tarjetan existan y su estado sea vigente, que el codigo de seguridad de la tarjeta sea valido, si la tarjeta esta expirada y si excede el limite de compra. Si paso todas las condiciones previas quiere decir que es una tarjeta valida por lo tanto puede comprar sino se agrega a la tabla rechazo.

[source, c]
----
create or replace function generacion_de_resumen(nro_client int ,anio int, m int) returns void as $$
    declare
        client record;
        tarj  record;
        term_tarj int;
        cierre_actual record;
        total float = 0;
	    v record;
	    num_resumen int;
        
    begin
    
        select * into client from cliente cl where cl.nro_cliente = nro_client;
        
        select * into tarj from tarjeta t where t.nro_cliente = nro_client;
        
        term_tarj = tarj.nro_tarjeta[16]::int;
        
        select * into cierre_actual from cierre c where anio = c.año and m = c.mes and term_tarj = c.terminacion;
        
        select coalesce(sum(monto),0) into total from   compra where tarj.nro_tarjeta = nro_tarjeta and
                                                fecha::date > cierre_actual.fecha_inicio and
                                                fecha::date < cierre_actual.fecha_cierre;


        insert into cabecera values ( default, client.nombre, client.apellido, client.domicilio,
        tarj.nro_tarjeta, cierre_actual.fecha_inicio, cierre_actual.fecha_cierre, cierre_actual.fecha_vto,total);
        
        select nro_resumen into num_resumen from cabecera where tarj.nro_tarjeta = nro_tarjeta and cierre_actual.fecha_inicio = desde;
        
        for v in select * from compra com,comercio comer where comer.nro_comercio = com.nro_comercio and
                    com.nro_tarjeta = tarj.nro_tarjeta and
                                            fecha::date > cierre_actual.fecha_inicio and
                                            fecha::date < cierre_actual.fecha_cierre loop
        
            insert into detalle values (num_resumen, default, v.fecha::date, v.nombre, v.monto);

        end loop;
        
        update compra set pagado = true where nro_tarjeta = tarj.nro_tarjeta and
                                            fecha::date > cierre_actual.fecha_inicio and
                                            fecha::date < cierre_actual.fecha_cierre;	
            
        ALTER SEQUENCE detalle_nro_linea_seq RESTART WITH 1;
    end; 
$$ language plpgsql;
.
.
.
----
A través de multiples querys obtenemos los valores necesarios para completar las tablas cabecera y detalle 
para generar el resumen de una compra.

[source, c]
----
create or replace function crear_alerta_compras()  returns trigger as $$
	declare
		tiempo_compra  interval := interval '1' minute;
		tiempo_compraCinco  interval := interval '5' minute;
		cant_compras_un_min int;
		cant_compras_cinco_min int;
		cp text;
		
	begin
		
		select cod_postal into cp from comercio where nro_comercio = new.nro_comercio;
		
		
		select count (cod_postal) into cant_compras_un_min from comercio where nro_comercio in 
			(select distinct nro_comercio from compra c where c.nro_tarjeta = new.nro_tarjeta and 
															c.fecha - new.fecha < tiempo_compra );

		
		select count (distinct cod_postal) into cant_compras_cinco_min from comercio where nro_comercio in 
			(select distinct nro_comercio from compra c where c.nro_tarjeta = new.nro_tarjeta and
															c.fecha - new.fecha < tiempo_compraCinco);

		
		
		if (cant_compras_cinco_min > 1) then
			insert into alerta values(default, new.nro_tarjeta, new.fecha , null , 5,'Se detectaron mas de 1 compra en 5 minutos');			
			return new;
		end if;  	
		
		if cant_compras_un_min > 1 then
			insert into alerta values(default, new.nro_tarjeta, new.fecha , null , 1,'Se detectaron mas de 1 compra en 1 minuto');
			return new;
		
		end if ;	
		
		
		return new;
		
	end; 
$$ language plpgsql;
create trigger alerta_automatica_compras_trg
after insert on compra
for each row
execute procedure crear_alerta_compras();
.
.
.
----
En esta funcion nos fijamos los codigos postales de los comercios donde se realizaron las compras y en caso de que se realizen en distintos comercios y mismo codigo postal en menos de un minuto insertamos una alerta. Si estas compras se realizaron en distintos codigos postales en menos de cinco minutos se inserta otra alerta. 

[source, c]
----
create or replace function crear_alerta()  returns trigger as $$
	declare
		mismo_dia  interval := interval '1 day';
		cant_rechazo int;
	begin
		insert into alerta values(default, new.nro_tarjeta, new.fecha , new.nro_rechazo, 0, new.motivo);
		select count(*) into cant_rechazo from rechazo where nro_tarjeta = new.nro_tarjeta and fecha - new.fecha < mismo_dia and new.motivo = 'supera límite de tarjeta';
		if (cant_rechazo > 1) then
			insert into alerta values(default, new.nro_tarjeta, new.fecha , new.nro_rechazo, 32,'Tarjeta suspendida por varios excesos de limite');
			update tarjeta set estado = '{"s","u","s","p","e","n","d","i","d","a"}' where nro_tarjeta = new.nro_tarjeta;
		end if;
		return new;
	end; 
$$ language plpgsql;
create trigger alerta_automatica_trg
after insert on rechazo
for each row
execute procedure crear_alerta();
.
.
.
----
Este trigger se ejecuta apartir de un rechazo por lo que automaticamente insertamos una alerta y verificamos que no haya tenido mas de dos rechazos con el motivo "supera limite tarjeta", en caso de que lo tuviera, suspendemos la tarjeta y agregamos una nueva alerta que explica lo ocurrido.

==== Funciones Auxiliares
[source, c]
----
create or replace function array_de_char_a_date(venc char[]) returns date as $$
    declare
        anio int;
        mes  int;
        result record;
    begin
        anio = venc[1]::int * 1000 + venc[2]::int * 100 + venc[3]::int * 10 +venc[4]::int;
        mes = venc[5]::int * 10 + venc[6]::int;
        select into result format('%s-%s-%s', anio, mes, 1)::date;

        raise notice 'Esta es la fecha que le paso % ', result;
        return result;
    end;
$$ language plpgsql;


create or replace function cargar_consumos_en_compra() returns void as $$
    declare
        v record;
    begin
        for v in select * from consumo loop
            perform autorizacion_de_compra  (v.nro_tarjeta, v.nro_comercio, '2020-11-15',v.monto, 'f');
        end loop;
    end;
$$ language plpgsql;


create or replace function generar_resumenes_del_anio() returns void as $$
    declare
        v record;
    begin
        for v in select * from cliente loop
            for m in 1..12 loop
				perform generacion_de_resumen (v.nro_cliente,'2020',m);
				end loop;
        end loop;
    end;
$$ language plpgsql;
.
.
.
----

==== Crear Tablas
[source, c]
----
create table cliente (nro_cliente int ,nombre text, apellido  text, domicilio text, telefono char[]);
create table comercio (nro_comercio int ,nombre text, domicilio text, cod_postal text, telefono char[]);
create table tarjeta (nro_tarjeta char[] ,nro_cliente int, val_desde char[], val_hasta char[], codigo_seguridad char[], limite_compra float, estado char[]);
create table compra (nro_operacion serial ,nro_tarjeta char[], nro_comercio int, fecha timestamp, monto float, pagado boolean);
create table rechazo (nro_rechazo serial, nro_tarjeta char[], nro_comercio int, fecha timestamp, monto float, motivo text);
create table cierre (año int, mes int, terminacion int, fecha_inicio date, fecha_cierre date, fecha_vto date);
create table cabecera (nro_resumen serial, nombre text, apellido text, domicilio text, nro_tarjeta char[], desde date, hasta date, vence date, total float);
create table detalle (nro_resumen int, nro_linea serial, fecha date, nombre_comercio text, monto float);
create table alerta (nro_alerta serial, nro_tarjeta char[], fecha timestamp, nro_rechazo int, cod_alerta int, descripcion text);
create table consumo (nro_tarjeta char[], codigo_seguridad char[], nro_comercio int, monto float)
.
.
.
----

==== Datos Clientes
[source, c]
----
insert into cliente values ('1','Fernando','Paz','Callao 345','{"1","1","3","4","5","6","8","7","6","5"}');
insert into cliente values ('2','Manolo','Lettiere','Matheu 3942','{"1","1","4","7","5","4","4","3","6","0"}');
insert into cliente values ('3','Carlota','Correa','San Martin 975','{"1","1","9","4","4","2","7","7","3","5"}');
insert into cliente values ('4','Florentina','Sosa','Fonruoge 3870','{"1","1","4","6","0","2","0","6","9","6"}');
insert into cliente values ('5','Yara','Leiva','Charcas 5128','{"1","1","4","7","7","7","7","6","3","8"}');
insert into cliente values ('6','Cristiano','Borroni','Av Centenario 837','{"1","1","4","7","4","3","2","2","7","3"}');
insert into cliente values ('7','Leonor','Ortiz','24 de septiembre 263','{"1","1","4","2","1","6","1","5","1","5"}');
insert into cliente values ('8','Levina','Dellucci','Thames 550','{"1","1","4","8","5","8","0","7","6","7"}');
insert into cliente values ('9','Salvino','Castiglione','Moreno 1785','{"1","1","4","8","8","3","5","2","9","1"}');
insert into cliente values ('10','Franco','Cruz','Nuñez 345','{"1","1","4","5","5","4","3","5","0","0"}');
insert into cliente values ('11','Virgilio','Angelo','Mitre 424','{"1","1","4","4","2","1","3","0","3","0"}');
insert into cliente values ('12','Galeno','Romero','Gonzalez 461','{"1","1","4","4","3","0","8","7","9","6"}');
insert into cliente values ('13','Rosa','Rousse','Av Centenario 743','{"1","1","4","7","4","3","8","4","9","5"}');
insert into cliente values ('14','Agustin','Arcuri','Fotheringham 282','{"1","1","4","4","6","2","2","8","0","8"}');
insert into cliente values ('15','Nekate','Longo','Av Besares 1170','{"1","1","4","4","2","7","8","2","6","3"}');
insert into cliente values ('16','Ventana','Garcia','Yrigoyen 739','{"1","1","4","4","5","6","4","8","3","5"}');
insert into cliente values ('17','Nevada','Lombardi','Boulogne Sur Mer 372','{"1","1","4","4","5","4","0","4","0","7"}');
insert into cliente values ('18','Telma','Chavez','Av Cabildo 2370','{"1","1","4","7","8","0","5","4","1","4"}');
insert into cliente values ('19','Augusto','Bravo','San Luis 2745','{"1","1","4","4","8","3","1","1","3","4"}');
insert into cliente values ('20','Romano','Cocci','Calle 24 1235','{"1","1","4","4","3","0","9","2","6","1"}')
.
.
.
----

==== Datos Comercios
[source, c]
----
insert into comercio values ('1','Adidas','Pte peron 3221','1643','{"1","1","4","9","2","1","1","9","7","1"}');
insert into comercio values ('2','Nike','Miraflores 2121','1643','{"1","1","4","4","5","1","8","7","6","5"}');
insert into comercio values ('3','Mc Donals','French 231','1643','{"1","1","4","4","1","1","0","9","6","5"}');
insert into comercio values ('4','Burger King','Av Almafuerte 436','1643','{"1","1","4","4","4","3","0","8","2","5"}');
insert into comercio values ('5','Compumundo','Guido Spano 2534','1643','{"1","1","4","4","5","5","3","2","2","3"}');
insert into comercio values ('6','Garbarino','Parana 3771','1642','{"1","1","4","5","5","6","3","3","6","8"}');
insert into comercio values ('7','Musimundo','Callao 3245','1642','{"1","1","4","3","0","2","8","7","3","5"}');
insert into comercio values ('8','Fravega','Falucho 5411','1642','{"1","1","4","1","3","4","8","6","3","0"}');
insert into comercio values ('9','Rodo','Av Corrientes','1642','{"1","1","4","4","4","2","1","7","1","8"}');
insert into comercio values ('10','Samsung','Callao','1642','{"1","1","4","8","3","5","1","1","6","5"}');
insert into comercio values ('11','Freddo','Pte peron 2121','1640','{"1","1","4","1","4","1","8","0","0","1"}');
insert into comercio values ('12','Mostaza','Ugarte 1212','1640','{"1","1","4","2","6","6","7","7","3","1"}');
insert into comercio values ('13','Green Eat','Haiti 3367','1640','{"1","1","4","4","5","6","1","7","3","5"}');
insert into comercio values ('14','Starbucks','Pte peron 1299','1640','{"1","1","4","4","5","2","2","5","6","3"}');
insert into comercio values ('15','Wendy','Palpa 782','1640','{"1","1","4","3","5","6","7","7","6","9"}');
insert into comercio values ('16','Bowen','Zelarrayan 485','1638','{"1","1","4","4","5","6","4","2","1","6"}');
insert into comercio values ('17','Cristobal Colon','Baigorria 1513','1638','{"1","1","4","2","5","6","2","7","1","5"}');
insert into comercio values ('18','Falabella','Pte peron 1576','1638','{"1","1","4","4","5","2","8","7","6","5"}');
insert into comercio values ('19','Carrefour','Ugarte 3221','1638','{"1","1","4","4","1","8","6","1","3","5"}');
insert into comercio values ('20','Etiqueta','Nazca 2356','1638','{"1","1","4","2","5","6","8","1","1","2"}')
.
.
.
----

==== Datos Consumos
[source, c]
----
insert into consumo values ('{"5","1","5","4","5","6","8","7","6","5","5","6","8","7","6","5"}','{"9","6","8","7"}','1','150.50');
insert into consumo values ('{"5","1","5","4","5","6","8","7","6","5","5","6","8","7","6","5"}','{"9","6","8","7"}','2','150.50');
insert into consumo values ('{"4","4","3","4","5","6","8","7","6","5","5","6","8","7","6","1"}','{"2","3","2","8"}','2','150.50');
insert into consumo values ('{"4","4","3","4","5","6","8","7","6","5","5","6","8","7","6","1"}','{"2","3","2","8"}','7','150.50');
insert into consumo values ('{"5","4","2","2","5","6","8","1","6","2","5","3","8","7","6","5"}','{"1","1","1","1"}','3','300.00');
insert into consumo values ('{"4","0","3","4","1","6","1","7","6","5","2","2","8","0","6","5"}','{"5","6","8","7"}','3','150.50');
insert into consumo values ('{"5","5","3","4","5","6","4","7","3","3","5","6","8","5","5","1"}','{"4","4","8","2"}','3','150000.50');
insert into consumo values ('{"4","0","5","4","1","6","1","7","6","5","2","2","8","0","6","5"}','{"5","6","8","8"}','5','155.50');
insert into consumo values ('{"5","5","0","4","5","6","8","7","6","2","2","6","2","2","6","5"}','{"2","6","8","7"}','5','155.50');
insert into consumo values ('{"5","5","3","4","5","6","4","7","3","3","5","6","8","5","5","1"}','{"4","4","8","2"}','4','150000.50');
insert into consumo values ('{"4","5","0","4","5","6","8","3","3","5","5","6","0","7","6","0"}','{"4","7","6","6"}','4','100.50');
.
.
.
----

==== Datos Tarjetas
[source, c]
----
insert into tarjeta values ('{"5","1","5","4","5","6","8","7","6","5","5","6","8","7","6","5"}','1','{"2","0","1","1","0","6"}','{"2","0","2","7","0","6"}','{"9","6","8","7"}','60000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","4","2","2","5","6","8","1","6","2","5","3","8","7","6","5"}','2','{"2","0","1","2","0","2"}','{"2","0","2","8","0","2"}','{"2","4","9","2"}','70000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","5","3","4","5","6","4","7","3","3","5","6","8","5","5","1"}','3','{"2","0","1","3","0","1"}','{"2","0","2","9","0","2"}','{"4","4","8","2"}','70000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","2","3","4","4","4","8","8","6","8","5","2","2","7","1","1"}','4','{"2","0","1","4","0","2"}','{"2","0","2","2","0","1"}','{"2","6","6","3"}','80000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","3","3","2","5","9","8","9","6","3","3","6","1","7","6","2"}','5','{"2","0","1","3","0","4"}','{"2","0","2","1","0","1"}','{"2","1","6","3"}','60000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","1","5","3","5","5","8","2","6","2","5","3","8","7","6","3"}','6','{"2","0","1","2","0","6"}','{"2","0","2","4","0","6"}','{"3","1","5","5"}','40000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","9","9","4","5","6","3","7","3","5","3","6","2","3","6","5"}','7','{"2","0","1","1","0","5"}','{"2","0","2","2","0","6"}','{"8","2","5","5"}','70000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","5","2","4","5","6","8","7","6","3","5","2","8","8","8","3"}','8','{"2","0","1","0","0","2"}','{"2","0","2","4","0","8"}','{"7","2","4","7"}','60000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","3","1","4","5","7","7","7","6","5","2","6","8","4","6","4"}','9','{"2","0","1","2","0","3"}','{"2","0","2","2","0","8"}','{"9","6","3","6"}','80000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"5","5","0","4","5","6","8","7","6","2","2","6","2","2","6","5"}','10','{"2","0","1","3","0","6"}','{"2","0","2","2","0","3"}','{"2","6","8","7"}','90000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","4","3","4","5","6","8","7","6","5","5","6","8","7","6","1"}','11','{"2","0","1","4","0","2"}','{"2","0","2","2","0","3"}','{"2","3","2","8"}','90000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","7","3","4","2","6","8","6","6","5","3","6","8","2","2","5"}','12','{"2","0","1","2","0","2"}','{"2","0","2","3","0","2"}','{"4","3","8","8"}','20000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","1","0","4","4","6","2","2","6","5","5","6","8","1","1","1"}','13','{"2","0","1","1","0","1"}','{"2","0","2","3","0","2"}','{"6","4","2","4"}','50000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","9","3","2","2","6","1","7","6","1","5","6","1","7","6","9"}','14','{"2","0","1","0","0","1"}','{"2","0","2","2","0","1"}','{"6","4","3","4"}','60000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","1","4","4","5","6","1","1","6","5","2","2","8","7","6","2"}','15','{"2","0","1","1","0","6"}','{"2","0","2","1","0","1"}','{"5","6","3","4"}','80000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","4","0","4","5","6","8","7","6","5","5","6","4","4","6","5"}','16','{"2","0","1","4","0","8"}','{"2","0","2","2","0","5"}','{"4","5","5","2"}','80000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","1","3","4","5","6","8","7","6","5","5","6","8","7","6","5"}','17','{"2","0","1","3","0","8"}','{"2","0","2","3","0","5"}','{"3","6","5","2"}','90000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","4","9","7","7","6","7","7","6","5","8","8","8","7","1","2"}','18','{"2","0","1","2","0","7"}','{"2","0","2","4","0","9"}','{"1","5","6","4"}','80000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","2","3","4","5","6","7","7","7","5","5","9","8","9","6","3"}','19','{"2","0","1","5","0","7"}','{"2","0","2","5","0","7"}','{"2","6","6","7"}','60000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","5","3","4","5","6","8","5","4","5","5","6","8","1","1","1"}','20','{"2","0","1","2","0","6"}','{"2","0","2","2","0","7"}','{"3","7","8","5"}','50000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","5","0","4","5","6","8","3","3","5","5","6","0","7","6","0"}','19','{"2","0","0","8","0","6"}','{"2","0","2","0","0","1"}','{"4","7","6","6"}','40000.00','{"v","i","g","e","n","t","e"}');
insert into tarjeta values ('{"4","0","3","4","1","6","1","7","6","5","2","2","8","0","6","5"}','20','{"2","0","0","9","0","6"}','{"2","0","1","5","0","6"}','{"5","6","8","7"}','40000.00','{"a","n","u","l","a","d","a"}');
insert into tarjeta values ('{"4","0","5","4","1","6","1","7","6","5","2","2","8","0","6","5"}','20','{"2","0","0","9","0","6"}','{"2","0","1","5","0","6"}','{"5","6","8","8"}','40000.00','{"s","u","s","p","e","n","d","i","d","a"}')
.
.
.
----

==== Foreign Keys
[source, c]
----
alter table tarjeta add constraint tarjeta_fk foreign key (nro_cliente) references cliente (nro_cliente);
alter table compra add constraint compra_nro_tarjeta_fk foreign key (nro_tarjeta) references tarjeta (nro_tarjeta);
alter table compra add constraint compra_nro_comercio_fk foreign key (nro_comercio) references comercio (nro_comercio);
alter table compra add constraint rechazo_nro_tarjeta_fk foreign key (nro_tarjeta) references tarjeta (nro_tarjeta);
alter table compra add constraint rechazo_nro_comercio_fk foreign key (nro_comercio) references comercio (nro_comercio);
alter table cabecera add constraint cabecera_fk foreign key (nro_tarjeta) references tarjeta (nro_tarjeta);
alter table detalle add constraint detalle_fk foreign key (nro_resumen) references cabecera (nro_resumen);
alter table alerta add constraint alerta_nro_tarjeta_fk foreign key (nro_tarjeta) references tarjeta (nro_tarjeta);
alter table alerta add constraint alerta_nro_rechazo_fk foreign key (nro_rechazo) references rechazo (nro_rechazo)
.
.
.
----

==== Primaries Keys
[source, c]
----
alter table cliente add constraint cliente_pk primary key (nro_cliente);
alter table comercio add constraint comercio_pk primary key (nro_comercio);
alter table tarjeta add constraint tarjeta_pk primary key (nro_tarjeta);
alter table compra add constraint compra_pk primary key (nro_operacion);
alter table rechazo add constraint rechazo_pk primary key (nro_rechazo);
alter table cierre add constraint cierre_pk primary key (año,mes,terminacion);
alter table cabecera add constraint cabecera_pk primary key (nro_resumen);
alter table detalle add constraint detalle_pk primary key (nro_resumen,nro_linea);
alter table alerta add constraint alerta_pk primary key (nro_alerta)
.
.
.
----

==== Borrar PKs y FKs
[source, c]
----
alter table tarjeta drop constraint tarjeta_fk;
alter table compra drop constraint compra_nro_tarjeta_fk;
alter table compra drop constraint compra_nro_comercio_fk;
alter table compra drop constraint rechazo_nro_tarjeta_fk;
alter table compra drop constraint rechazo_nro_comercio_fk;
alter table cabecera drop constraint cabecera_fk;
alter table detalle drop constraint detalle_fk;
alter table alerta drop constraint alerta_nro_tarjeta_fk;
alter table alerta drop constraint alerta_nro_rechazo_fk;
alter table cliente drop constraint cliente_pk;
alter table comercio drop constraint comercio_pk;
alter table tarjeta drop constraint tarjeta_pk;
alter table compra drop constraint compra_pk;
alter table rechazo drop constraint rechazo_pk;
alter table cierre drop constraint cierre_pk;
alter table cabecera drop constraint cabecera_pk;
alter table detalle drop constraint detalle_pk;
alter table alerta drop constraint alerta_pk;
.
.
.
----

== Conclusion 

Tras realizar el trabajo practico, mas alĺa de lograr el objetivo, aprendimos a manejar una base de datos con un  lenguaje nuevo como Go y las dificultades que esto puede generar. Al ser un nuevo lenguaje este tiene una sintaxis a la cual ninguno de nosotros estaba acostumbrado. Se tuvo que aprender durante la marcha demorando el desarrollo del tp. 
Tuvimos discusiones de diseño en cuanto al realizar las funciones totalmente el Go o dividirla en codigo de PostgreSQL. Tras debatir llegamos a un acuerdo, crear archivos que contienen comandos de SQL que son ejecutados por el codigo de Go.
En cuanto a la implementacion de BoltDB, al utilizar Go, nos parecio de mas facil acceso para ingresar y leer datos pero nos da una sensacion de poco confiabilidad comparado con bases de datos SQL, ya que pudimos acceder al codigo de la base usando el comando CAT o VIM. Otra diferencia que encontramos es que en la bases de datos PostgreSQL podemos ver un mejor orden de las datos en comparacion a BoltDB
    





